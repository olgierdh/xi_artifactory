TMS470 C/C++ CODE GENERATION TOOLS
15.12.3 June 2016
Defect History

-------------------------------------------------------------------------------
Table of Contents
-------------------------------------------------------------------------------
1. Defects fixed in TMS470 Code Generation Tools release 15.12.3.LTS
2. Defects fixed in TMS470 Code Generation Tools release 15.12.2.LTS
3. Defects fixed in TMS470 Code Generation Tools release 15.12.1.LTS
4. Defects fixed in TMS470 Code Generation Tools release 15.12.0.LTS
5. Current Known Issues


===============================================================================
1. Defects fixed in TMS470 Code Generation Tools release 15.12.3.LTS
===============================================================================

The following 7 defects were fixed in TMS470 Code Generation Tools release
15.12.3.LTS, released June 2016.

-------------------------------------------------------------------------------
FIXED SDSCM00050005
-------------------------------------------------------------------------------

Summary            : Compiler mistakenly issues MISRA diagnostic 12.9 for a
                     float point type

Fixed in           : 15.12.3.LTS
Severity           : S3 - Minor
Affected Component : C/C++ Compiler (cl)
Duplicate Defects  : SDSCM00052908, SDSCM00050841

Release Notes:
  The compiler will mistakenly emit a warning for MISRA-C:2004 12.9/R ("The
  unary minus operator shall not be applied to an expression whose underlying
  type is unsigned") when the unary minus operator is applied to any type that
  is not a signed integral type, such as a floating-point type.

Workaround:
  None.

-------------------------------------------------------------------------------
FIXED SDSCM00052833
-------------------------------------------------------------------------------

Summary            : Linker INTERNAL ERROR with object files with DWARF
                     information compiled by IAR compiler

Fixed in           : 15.12.3.LTS
Severity           : S2 - Major
Affected Component : Linker
Duplicate Defects  : SDSCM00052909

Release Notes:
  The IAR compiler generates some DWARF debugging entries that the TI linker
  does not handle correctly. In some cases, the TI linker may crash with a
  segmentation fault or other internal error.

Workaround:
  Add option --compress_dwarf=off

-------------------------------------------------------------------------------
FIXED SDSCM00052854
-------------------------------------------------------------------------------

Summary            : Compiler crashes when MISRA checking is enabled and an
                     empty struct initializer is used

Fixed in           : 15.12.3.LTS
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Release Notes:
  The compiler may crash when MISRA checking is enabled and an empty struct,
  union, or array initializer is used.
  Note that MISRA checking is meant to be used in strict ANSI mode (--
  strict_ansi), and in this mode empty initializers are not allowed.

Workaround:
  Use {0}, not {}, to initialize the struct

-------------------------------------------------------------------------------
FIXED SDSCM00052861
-------------------------------------------------------------------------------

Summary            : NULL deref when using --minimize_trampolines=postorder

Fixed in           : 15.12.3.LTS
Severity           : S2 - Major
Affected Component : ELF Linker

Release Notes:
  When using the option --minimize_trampolines=postorder, the linker may get a
  SIGSEGV even if the option --trampolines=off is used.

Workaround:
  As a workaround, use the option --trampolines=off and do not use the option
  --minimize_trampolines

-------------------------------------------------------------------------------
FIXED SDSCM00052869
-------------------------------------------------------------------------------

Summary            : Incorrect opcode for LDMED and LDMFA

Fixed in           : 15.12.3.LTS
Severity           : S2 - Major
Affected Component : Assembler

Release Notes:
  LDMED and LDMFA variants of LDM (load multiple) instructions are not properly
  supported by the TI ARM assembler and disassembler.

Workaround:
  None

-------------------------------------------------------------------------------
FIXED SDSCM00052888
-------------------------------------------------------------------------------

Summary            : Illegal instruction inside IT sequence causes assembler
                     to abort with segmentation fault

Fixed in           : 15.12.3.LTS
Severity           : S2 - Major
Affected Component : Assembler

Release Notes:
  The assembler crashes on a malformed test case.  It had a MOVEQ with a
  missing comma between the two operands.  When compiled in Thumb, and
  the instruction appears under an IT, the assembler crashes.

Workaround:
  None.

-------------------------------------------------------------------------------
FIXED SDSCM00052901
-------------------------------------------------------------------------------

Summary            : REVSH used where REV16 needed?

Fixed in           : 15.12.3.LTS
Severity           : S2 - Major
Affected Component : Code Generator

Release Notes:
  The issue can be reproduced easily with following C function:
  unsigned long swapBytesInWord(unsigned long us)
  {
  return 0xfffflu & (((us & 0xfflu) << 8u) | ((us & 0xff00lu) >> 8u));
  }

  In assembly, the compiler with -O0 optimizations enabled provides :
  REVSH A1, A1
  BX LR

  Even if masks are casted in 16-bits data, the compiler uses the REVSH instruction 
  that extend sign to 32-bits...
  It should be REV16 instruction instead.
  
Workaround:
  None.


===============================================================================
2. Defects fixed in TMS470 Code Generation Tools release 15.12.2.LTS
===============================================================================

The following 5 defects were fixed in TMS470 Code Generation Tools release
15.12.2.LTS, released April 2016.

-------------------------------------------------------------------------------
FIXED SDSCM00052682
-------------------------------------------------------------------------------

Summary            : Linker issues an error about Tag_ABI_VFP_args attribute
                     value of "0" when linking with IAR object files

Fixed in           : 15.12.2.LTS
Severity           : S2 - Major
Affected Component : Linker

Release Notes:
  Starting with v15.12.2.LTS, the TI TMS470 Code Generation Tools will now
  recognize the presence of a Tag_ABI_VFP_ags build attribute with a value of 3
  which indicates compatibility with other object files that have a
  Tag_ABI_VFP_args attribute with a value of 0, 1, or 3. Furthermore, the linker
  will now properly handle an incoming object file with a Tag_ABI_VFP_args
  attibute value of 3 in its object file compaibility checking.

Workaround:
  Use --diag_suppress=16004 or --diag_warning=16004

-------------------------------------------------------------------------------
FIXED SDSCM00052688
-------------------------------------------------------------------------------

Summary            : Compiler fails to accept __MRC(15, ...

Fixed in           : 15.12.2.LTS
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Release Notes:
  Compiler does not accept the MCR, MRC, MCRR, and MRRC instrinsics.

Workaround:
  No workaround.

-------------------------------------------------------------------------------
FIXED SDSCM00052699
-------------------------------------------------------------------------------

Summary            : Compiler discards write to a volatile local struct
                     member

Fixed in           : 15.12.2.LTS
Severity           : S2 - Major
Affected Component : Optimizer

Release Notes:
  When volatile appears in a struct definition ...
  
      struct device {
          volatile unsigned tcc;
      } dev;
  
  The compiler doesn't honor it. References to dev.tcc still get optimized away.

Workaround:
  No workaround.

-------------------------------------------------------------------------------
FIXED SDSCM00052799
-------------------------------------------------------------------------------

Summary            : Include math.h and use --float_operations_allowed=32,
                     then compiler mistakenly issues message about 64-bit
                     float operations

Fixed in           : 15.12.2.LTS
Severity           : S2 - Major
Affected Component : Runtime Support Libraries (RTS)

Release Notes:
  Suppress the 64-bit floating point operations are not allowed diagnostic for
  header functions.

Workaround:
  None.

-------------------------------------------------------------------------------
FIXED SDSCM00052805
-------------------------------------------------------------------------------

Summary            : Decomposition error on while(*ptr++) where ptr points to
                     volatile

Fixed in           : 15.12.2.LTS
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Release Notes:
  The while(*ptr++) loop where ptr points to volatile is handled incorrectly by
  the code generation tool.

Workaround:
  No workaround.


===============================================================================
3. Defects fixed in TMS470 Code Generation Tools release 15.12.1.LTS
===============================================================================

The following 1 defect was fixed in TMS470 Code Generation Tools release
15.12.1.LTS, released January 2016.

-------------------------------------------------------------------------------
FIXED SDSCM00052668
-------------------------------------------------------------------------------

Summary            : Linker fails to auto-build missing RTS library, because
                     Windows executable mklib.exe is missing

Fixed in           : 15.12.1.LTS
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Release Notes:
  No Information Available; please see defect details.

Workaround:
  None.


===============================================================================
4. Defects fixed in TMS470 Code Generation Tools release 15.12.0.LTS
===============================================================================

The following 8 defects were fixed in TMS470 Code Generation Tools release
15.12.0.LTS, released December 2015.

-------------------------------------------------------------------------------
FIXED SDSCM00049912
-------------------------------------------------------------------------------

Summary            : Float NaN converted to double incorrectly turned into
                     Inf

Fixed in           : 15.12.0.LTS
Severity           : S2 - Major
Affected Component : Runtime Support Libraries (RTS)

Release Notes:
  The helper function to convert float values to double values incorrectly turns
  NaN values into Inf. The helper function in both EABI and COFF are affected.

Workaround:
  Manually check for NaN values where they are possible if software floating
  point conversions are required.

-------------------------------------------------------------------------------
FIXED SDSCM00050834
-------------------------------------------------------------------------------

Summary            : Assembler doesn't generate relocation entry for weak
                     symbol

Fixed in           : 15.12.0.LTS
Severity           : S2 - Major
Affected Component : Assembler

Release Notes:
  The assembler may not generate a relocation entry for a weak symbol. This may
  result in a call being permanently bound to the local definition.

Workaround:
  Use --gen_func_subsections.

-------------------------------------------------------------------------------
FIXED SDSCM00052238
-------------------------------------------------------------------------------

Summary            : Strong function symbol removed from linked ICODE with
                     -o4

Fixed in           : 15.12.0.LTS
Severity           : S2 - Major
Affected Component : ELF Linker

Release Notes:
  At --opt_level=4, weak symbols will be used when a strong symbol should be
  preferred.

Workaround:
  Use --opt_level=3 or below.

-------------------------------------------------------------------------------
FIXED SDSCM00052265
-------------------------------------------------------------------------------

Summary            : Flexible array with initializer not handle correctly

Fixed in           : 15.12.0.LTS
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Release Notes:
  Zero-length arrays is a GCC extension supported by TI compilers. The zero-
  length array extension also defines static initialization of C99 flex arrays.
  Static initialization of flex arrays should work in C99 mode when GCC
  extensions are enabled. Although the parser accepted these initializations,
  they were not output in assembly.

Workaround:
  None.

-------------------------------------------------------------------------------
FIXED SDSCM00052339
-------------------------------------------------------------------------------

Summary            : demangler --output option does not work at all

Fixed in           : 15.12.0.LTS
Severity           : S2 - Major
Affected Component : Demangler (dem)

Release Notes:
  The --output option of armdem does not work at all. You will always get the
  error message ">> Cannot open output file '(null)'"

Workaround:
  armdem file.asm > file.dis

-------------------------------------------------------------------------------
FIXED SDSCM00052430
-------------------------------------------------------------------------------

Summary            : 64-bit CRC values are truncated to 32-bits in linker map
                     file and linker XML info file

Fixed in           : 15.12.0.LTS
Severity           : S2 - Major
Affected Component : Linker

Release Notes:
  The Windows version of the compiler does not print the CRC value correctly
  for 64-bit CRC algorithms in the linker map file or the linker XML info
  file. Only the lower 32 bits of the 64-bit CRC value are correctly
  displayed. The value stored in the object file is correct. The Linux tools
  do not have this problem.

Workaround:
  Use the Linux toolset to generate the linker map file and linker XML info
  file, or just ignore the reported CRC value in those files.

-------------------------------------------------------------------------------
FIXED SDSCM00052529
-------------------------------------------------------------------------------

Summary            : Optimizer assumes enum variable can only have value of
                     enumeration constants

Fixed in           : 15.12.0.LTS
Severity           : S2 - Major
Affected Component : Optimizer

Release Notes:
  If an enumerated type is defined to have only two constants that evaluate to 0
  and 1, then the compiler will assume that only those two values are possible.
  However, the C++ and C standards allow variables of enumerated types to hold
  other values as well; if other values are used, the compiler may produce
  incorrect code.

Workaround:
  Don't make enumerated types with constants only for 0 and 1 if other values
  may be used. Either add a third value, or use values different than 0 and 1,
  or avoid using values that aren't the enumeration constants.

-------------------------------------------------------------------------------
FIXED SDSCM00052565
-------------------------------------------------------------------------------

Summary            : On MSP432, giving #pragma vector= non function name
                     arguments causes segfault

Fixed in           : 15.12.0.LTS
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Release Notes:
  On MSP432, giving #pragma vector= non function name arguments may cause a
  segfault. For example,
  
  #pragma vector = 0x60u
  __interrupt void my_isr(void) {}
  
  will cause a segfault, but
  
  #pragma vector = default_isr
  __interrupt void my_isr(void) {}
  
  will not.

Workaround:
  Use symbol names as arguments to #pragma vector=.


===============================================================================
5. Current Known Issues
===============================================================================

The following 60 known issues exist for TMS470 Code Generation Tools release
15.12.3.LTS as of June 2016.

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00008248
-------------------------------------------------------------------------------

Summary            : Compilers on PC will not work without TMP set
Affected Component : C/C++ Compiler (cl)
Duplicate Defects  : SDSCM00034609

Description:
  
  When compiling on the PC, the code generator cannot find the icode
  file produced by the parser if the environment variable TMP is no
  set. If TMP is set, then all appears well.

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00008465
-------------------------------------------------------------------------------

Summary            : Language Conformance: crash because of void pointer
                     dereference
Affected Component : Parser

Description:
  Compiler generates multiple INTERNAL ERRORs when code like the following
  is compiled:
  
    void dr106_1(void *pv, int i)
    {
        *pv;
        i ? *pv : *pv;
        *pv, *pv;
    }

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00008534
-------------------------------------------------------------------------------

Summary            : Linker -xml_link_info option doesn't work when in a
                     command file
Affected Component : Linker

Description:
  
  The option --xml_link_info=file.xml does not work when it is
  placed inside a linker command file.

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00008537
-------------------------------------------------------------------------------

Summary            : assembler expression ~(0x80000000) evaulates as
                     0x80000000
Affected Component : Assembler

Description:
  The following expression is evaluating incorrectly in the assembler:
  
    .eval ~(0x80000000), mask
  
  mask ends up getting assigned 0x80000000, whereas I expect it to be
  0x7FFFFFFF.
  It seems that any constant with bit 31 set will incorrectly return 0x80000000

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00008543
-------------------------------------------------------------------------------

Summary            : Forward reference in .space generates an internal error
Affected Component : Assembler

Description:
  If you attempt to assemble:
  
     .space 0+a
   b
   a .set 1
  
  the assembler will generate an internal error.
  
  This happens with v3.83 and v4.1.0B1 on Solaris.
  
  If you change the code to:
  
     .space a
   b
   b .set 1
  
  the correct error message is generated, 'Absolute, well-defined integer value
  expected'.

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00008685
-------------------------------------------------------------------------------

Summary            : DWARF does not correctly represent variables stored in
                     register pairs
Affected Component : Code Generator

Description:
  
  In the attached example, variables 'var1' and 'var2' are both long
  long types, and are stored in A7:A6 and B5:B4. However, the DWARF
  information shows var1 only to be in A6, and var2 only to be in B4:
  
        [000000e8] DW_TAG_variable
        DW_AT_name var1
        DW_AT_symbol_name _var1
        DW_AT_type [00000113]
        DW_AT_location { DW_OP_reg6 }
  
        [000000fa] DW_TAG_variable
        DW_AT_name var2
        DW_AT_symbol_name _var2
        DW_AT_type [00000113]
        DW_AT_location { DW_OP_reg20 }

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00008928
-------------------------------------------------------------------------------

Summary            : Extern inline functions are not supported in the C/C++
                     Compiler
Affected Component : Parser
Duplicate Defects  : SDSCM00018364

Description:
  Users cannot create global accessible code with INLINE functions.
  The V3.00 compiler/code generator does not create globally accessible
  code for functions which are declared inline. A simple example is:
  
    inline int x() { return 1; }
    int y() {return 2;}
  
  When compiled with 'cl6x -k -c test.c', a warning is produced:
  
    'test.c', line 1: warning: function 'x' was declared but
    never referenced
  
  and the resulting assembler file (test.asm) does not
  contain any code for x(). The documentation states that code
  declared inline will be inlined in that module but global code will
  also be generated (section 2.10.3.2 in v3.00 C Compiler manual). The
  new compiler is overly aggressive in its optimizations. If y() is
  modified to call x() then code is generated for x() unless the
  optimizer is also invoked (by using -x2).

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00014430
-------------------------------------------------------------------------------

Summary            : calloc doesn't check arguments to make sure the
                     requested size is reasonable
Affected Component : Runtime Support Libraries (RTS)

Description:
  The function calloc() is required to return a pointer to memory representing
  "nelem" copies of "size" bytes, or NULL if the request cannot be satisfied.
  However, for some values of "nelem" and "size" (specifically when the result
  of nelem*size wraps around), calloc can return a pointer to an object that is
  not large enough, rather than NULL.
  
  For example, on a 32-bit target, if the user calls calloc(0x00010001,
  0x00010001), even though each argument by itself is reasonable, the request
  cannot be satisfied because the product is 0x000100020001, which exceeds
  size_t. (Note that we cannot check for overflow by checking if the product is
  less than either argument, which is commonly done for unsigned addition.)
  Arguably, we can try to claim that it is undefined behavior to make a call to
  calloc where the product would exceed size_t, but there doesn't seem to be
  anything in the standard which says so.
  
  The problem is worse on 16-bit targets, where calloc(0x0101, 0x0101) is enough
  to overflow size_t. It may not be obvious to the user that this overflows.
  
  Another concern is that it is hard to figure out whether a multiplication will
  overflow without having a double-width multiply available.

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00018691
-------------------------------------------------------------------------------

Summary            : Linker gives misleading warning when dot expressions
                     used in SECTION directive for .stack section
Affected Component : Linker

Description:
  Linker gives the warning:
  
  warning: creating ".stack" section with default size of 0x800; use the -stack
  option to change the default size
  
  even when the application does not link in boot code from RTS lib.
  
  A linker command file is used that contains a specialized SECTION directive
  for the ".stack" section. Because of a series of ". += <number>" assignments
  in the section spec, the linker is forced to increase the size of the .stack
  section to 0xc00. The linker is doing the correct thing by making a .stack
  section large enough to accommodate the dot expressions, but the diagnostic is
  misleading, as 0x800 isn't the final size of the .stack section.

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00033221
-------------------------------------------------------------------------------

Summary            : The linker allows linking of VFP ARM object files with
                     non-VFP TI object files, but does not allow linking of
                     two VFP files
Affected Component : C/C++ Compiler (cl)

Description:
  The linker does not generate an error if the user attempts to link together an
  object file compiled with the ARM tools with VFP support and an object file
  compiled with TI tools without VFP support.
  
  Also, the linker does generate an error message when trying to link together
  two VFP files, one compiled with ARM tools and the other with TI tools.

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00036770
-------------------------------------------------------------------------------

Summary            : LDREXD and STREXD instructions erroneously generate
                     errors on Cortex A8 and R4
Affected Component : Assembler

Description:
  LDREXD and STREXD are valid instructions on Cortex R4 and A8 architectures but
  the assembler generates errors. The first error states that [Rn] must be a
  register indirect and the second complains of unexpected trailing operands.

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00036773
-------------------------------------------------------------------------------

Summary            : LDM/STM -DA/FA/IB/ED viariant instructions erroneously
                     accepted by assembler for Cortex-M3
Affected Component : Assembler

Description:
  LDM and STM instructions ending with DA, FA, IB and ED are not available in
  the Thumb instruction set, but the assembler accepts these for Cortex-M3 and
  converts them to LDM and STM instructions ending with IA.W.

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00036874
-------------------------------------------------------------------------------

Summary            : Section relative ELF symbol values in partially linking
                     object files should hold the section offset for the
                     symbol
Affected Component : ELF Linker

Description:
  The symbol value in an ELF relocatable file should be the offset from the
  beginning of the section. Typically the sections all start at address 0, so
  the value corresponds to its address in the file. In a partially linking
  object file, the sections will start at different addresses. The symbol values
  contain the absolute address instead of the offset.

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00037008
-------------------------------------------------------------------------------

Summary            : Linker outputting wrong build attribute name for EABI
                     TAG_VFP_arch on ARM targets
Affected Component : ELF Linker

Description:
  For TMS470, linker outputs EABI build attribute TAG_VFP_arch name as "Producer
  Minor Version + 1" instead of the correct name for the specific tag value. The
  TI build attribute TAG_VFP_arch name is printed correctly. The names are
  entered correctly for the EABI VFP_arch tag values but are not being accessed.

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00037086
-------------------------------------------------------------------------------

Summary            : ARM assembler allows incorrect VFP registers for some
                     instructions on D16 VFP architectures
Affected Component : Assembler

Description:
  ARM assembler allows the use of VFP registers D16-D31 on D16 VFP targets for
  the following VFP instructions: single and multiple loads and stores, pop,
  push, and register transfers between VFP and core registers.

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00037227
-------------------------------------------------------------------------------

Summary            : ARM disassembler error for VMRS instruction
Affected Component : Disassembler (dis)

Description:
  The ARM disassembler errorneously disassembles "VMRS APSR_[bits], FPSCR" as
  "VMSR PC, FPSCR". The instruction is formatted as "FMSTAT" in the code
  generator in vfp.md (vfp_transfer_status_to_cpsr).

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00037308
-------------------------------------------------------------------------------

Summary            : Assembler does not encode the proper offset for a VLDR
                     immediate instruction in thumb 2 mode
Affected Component : Assembler

Description:
  In thumb 2 mode, the value of the PC register at a given instruction is PC+4
  (in ARM it is PC+8). When encoding the VLDR instruction the assembler always
  encodes the instruction as if the PC is PC+8. This will cause the VLDR
  instruction to never work correctly in thumb 2 mode.

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00038278
-------------------------------------------------------------------------------

Summary            : ARM floating point conversion routines do not support
                     NaN
Affected Component : Runtime Support Libraries (RTS)

Description:
  The ARM assembly routines that handle converting floating point types do not
  handle NaN correctly. In these routines NaN is considered to be infinity.

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00039054
-------------------------------------------------------------------------------

Summary            : Compiler reports a violation of Misra rule 12.8 for a
                     structure variable
Affected Component : C/C++ Compiler (cl)

Description:
  MISRA warning (MISRA-C:2004 12.8/R) The right-hand operand of a shift operator
  shall lie between zero and one less than the width in bits of the underlying
  type of the left-hand operand
  
  In the following code I get MISRA 12.8 warning on myVar = myStruct.aVar >> 16
  shift. Note that shift of unstructured variable myVar = myVar >> 16 is okay.
  
      typedef struct
      {
          unsigned long aVar;
      } myStruct_T;
  
      myStruct_T myStruct = {0xFFFFFFFFUL};
      unsigned long myVar;
  
      myVar = myStruct.aVar >> 16;
      myVar = myVar >> 16;
  
  
  

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00039220
-------------------------------------------------------------------------------

Summary            : Assembler does not accept the SP operand of the SRSDB
                     instruction
Affected Component : Assembler

Description:
  The assembler accepts SRSDB #<mode>, but the reference manual specifies that
  the instruction should have an SP! operand.

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00039236
-------------------------------------------------------------------------------

Summary            : Sometimes MISRA rule 19.15 is incorrectly emitted.  The
                     rule is about failing to use an inclusion guard in a
                     header file.
Affected Component : Parser

Description:
  In the attached test case rule 19.15 gets emitted even though the files
  mentioned do have proper inclusion guards.

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00039626
-------------------------------------------------------------------------------

Summary            : ARM assembler does not issue a warning for PC-relative
                     loads when --embedded_constants=off
Affected Component : Assembler

Description:
  When the --embedded_constants=of option is used, the assembler is supposed to
  issue an error message if it detects any PC-relative loads. It does this for
  LDR instructions that are 32-bits long, but not for the 16-bit versions.

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00039636
-------------------------------------------------------------------------------

Summary            : When creating a partial linked ELF object file, the
                     linker uses virtual addresses instead of relative
                     addresses.
Affected Component : Linker

Description:
  In ELF, relocatable object files should always using section relative values
  for relocation offsets and symbols values. When creating a partially linked
  object file the linker uses virtual addresses for these values.

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00040522
-------------------------------------------------------------------------------

Summary            : _ssatl intrinsic allows 3rd argument to be 0 resulting
                     in an assembler error.
Affected Component : Parser

Description:
  The SSAT instruction does not accept a 0 for the immediate argument. We should
  ensure in the parser that 0 is not allowed.

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00040523
-------------------------------------------------------------------------------

Summary            : The _ssat16 intrinsic allows literals in the range of
                     0-31, but the SSAT16 instruction only accepts values
                     from 1-16
Affected Component : Parser

Description:
  The parser should catch this so the assembler doesn't generate an error.

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00040934
-------------------------------------------------------------------------------

Summary            : Structure is not initialized correctly when using -o2 or
                     -o3 optimization
Affected Component : Optimizer

Description:
  There is a problem with the initialization of a structure using symbols
  generated in the linker command file. We use symbols generated in the linker
  cmd file using the dot operator. These symbols are used as an initial value
  for a class/struct with a constructor. In our case we want the difference of
  two addresses that the linker generates.
  
  When using optimization -o2 or -o3, the compiler generates .cinit entries
  instead of the constructor call. In those .init-entries it doesn't use the
  difference of the addresses; instead it uses the first symbol.
  
  When turning off optimization or using lower level of opt than -o2, the
  constructor calls are generated and the struct is initialized correctly.

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00042344
-------------------------------------------------------------------------------

Summary            : Compiler generates internal error: illegal
                     initialization or segmentation fault
Affected Component : C/C++ Compiler (cl)

Description:
  The attached test case generates a segmentation fault when compiled with CGT
  6.1.x and 7.0.x.
  It generates the following error when compiled with 7.2.5 and 7.3.1 but does
  generate a .obj file.
  
  Build with: cl6x --gcc seg_fault.c
  
  >> INTERNAL ERROR: ILLEGAL INITIALIZATION
  
  This may be a serious problem. Please contact customer support with a
  description of this problem and a sample of the source files that caused this
  INTERNAL ERROR message to appear.
  
  Note: May lose variable initialization information
  
  ... continuing compilation ...
  
  User would like to know if there is a workaround.

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00042418
-------------------------------------------------------------------------------

Summary            : Internal error when compiling code with WEAK functions;
                     linker crash
Affected Component : C/C++ Compiler (cl)

Description:
  /*
  Command line:
  cl470 --abi=eabi weak2.c -z -l
  c:\Programme\TexasInstruments\ccsv4\tools\compiler\tms470\lib\libc.a
  
     Resulting output:
     <Linking>
     warning: output section ".data" refers to load symbol "weakFunc" and hence
     cannot be compressed; compression "rle" is ignored
     warning: output section ".data" refers to load symbol "weakFunc" and hence
     cannot be compressed; compression "rle" is ignored
     table.c:3601:internal fatal error #10225: (.cinit..data.load)
  
       This application has requested the Runtime to terminate it in an unusual
       way.
       Please contact the application's support team for more information.
  
       INTERNAL ERROR: lnk470 aborted
  
  
       This is a serious problem. Please contact Customer
       Support with this message and a copy of the input file
       and help us to continue to make the tools more robust.
  
  
       >> Compilation failure
  
     Toolchain: TMS470 4.6.4 or 4.6.6 on 32-bit WinXP SP3.
     */
  
  #pragma WEAK(weakFunc);
  extern void weakFunc();
  
  void (*ptr)() = weakFunc;
  
  int main()
  {
     if (ptr)
        ptr();
  }

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00042434
-------------------------------------------------------------------------------

Summary            : Compiler misreports Misra warning 6.4 for bitfield
                     definitions
Affected Component : C/C++ Compiler (cl)
Duplicate Defects  : SDSCM00043122

Description:
  Compiler misreports Misra warning 6.4 for bitfield definitions.
  
  typedef unsigned int uint16_t;
  typedef unsigned int bool_t;
  #define FALSE ((bool_t)0U)
  #define TRUE ((bool_t)1U)
  
  typedef struct mystructtag
  {
    uint16_t u16_hw_rev1;
    bool_t bl_hardware_supported:1;       /* this violates rule 6.4 */ 
  } st_software_info_t ;
  
  This generates the warning:
  
  "misra_test.c", line 9: warning: (MISRA-C:2004 6.4/R) Bit fields shall only be
  defined to be of type unsigned int or signed int
  
  Related forum thread:
  http://e2e.ti.com/support/development_tools/compiler/f/343/t/147639.aspx
  
  According to Misra, this is not a Misra violation.
  http://www.misra-
  c.com/forum/viewtopic.php?f=62&t=1167&sid=6fd53ec7591d33a4fa1b38e975c580bc

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00042435
-------------------------------------------------------------------------------

Summary            : Compiler misreports Misra warning 10.1
Affected Component : C/C++ Compiler (cl)

Description:
  Compiler misreports Misra warning 10.1 with the following code:
  
  typedef unsigned int uint16_t;
  typedef unsigned int bool_t;
  #define FALSE ((bool_t)0U)
  #define TRUE ((bool_t)1U)
  
  typedef struct mystructtag
  {
    uint16_t u16_hw_rev1;
    bool_t bl_hardware_supported:1;       /* this violates rule 6.4 */ 
  } st_software_info_t ;
  
  
  void main(void)
  {
  
  uint16_t u16_rev1_min, u16_tmp;
  st_software_info_t sts_sw_info;
  u16_rev1_min = 900U;
  
  sts_sw_info.bl_hardware_supported = FALSE;
  
  if (sts_sw_info.bl_hardware_supported == FALSE)     /* this violates rule 10.1 */
  {
    /* do something... */
  }
  
  if (sts_sw_info.u16_hw_rev1 >= u16_rev1_min)       /* this violates rule 10.1 */
  {
    /* do something... */
  }
  
  u16_tmp = sts_sw_info.u16_hw_rev1;
  if (u16_tmp >= u16_rev1_min)       /* this does not violates rule 10.1 */
  {
    /* do something... */
  }
  
  The warning is:
  
  "misra_test.c", line 22: warning: (MISRA-C:2004 10.1/R) The value of an
  expression of integer type shall not be implicitly converted to a different
  underlying type if it is not a conversion to a wider integer type of the same
  signedness
  "misra_test.c", line 27: warning: (MISRA-C:2004 10.1/R) The value of an
  expression of integer type shall not be implicitly converted to a different
  underlying type if it is not a conversion to a wider integer type of the same
  signedness
  
  
  Related forum thread:http://e2e.ti.com/support/development_tools/compiler/f/3-
  43/t/147639.aspx
  
  Related Misra threads that say this is not a Misra violation:
  http://www.misra-
  c.com/forum/viewtopic.php?f=62&t=1167&sid=6fd53ec7591d33a4fa1b38e975c580bc
  http://www.misra-
  c.com/forum/viewtopic.php?f=66&t=1168&sid=6fd53ec7591d33a4fa1b38e975c580bc

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00042945
-------------------------------------------------------------------------------

Summary            : -pdse=195 causes an error under EABI if any standard
                     header file is included
Affected Component : Runtime Support Libraries (RTS)

Description:
  This is the same bug as CQ19871. The problem appears to be that
  _AEABI_PORTABILITY_CHECK is defined in terms of _AEABI_PORTABILITY_LEVEL != 0
  where _AEABI_PORTABILITY_LEVEL is not defined. This same idiom is used in many
  header files.

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00043043
-------------------------------------------------------------------------------

Summary            : Array that is correctly initialized erroneously gets a
                     MISRA diagnostic about size not being specified
Affected Component : C/C++ Compiler (cl)

Description:
  For this input ...
  
      int16_t y[]={1,5,8};
  
  The compiler incorrectly issues this diagnostic ...
  
  "try1.c", line 2: warning: (MISRA-C:2004 8.12/R) When an array is declared
  with external linkage, its size shall be stated explicitly or
  defined implicitly by initialisation

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00044035
-------------------------------------------------------------------------------

Summary            : float library functions misbehave with -me
                     --float_support=fpalib
Affected Component : Runtime Support Libraries (RTS)

Description:
  Fails with optmization, passes with --no_high_level_opt, but the optimizer
  seems to be doing the right thing.
  
  Something is swapping the words in the double. If the words for each float
  constant in the assembly code are reversed, the test case works. I don't know
  whether the compiler is creating the float constants with the wrong endianness
  or the library is handling it with the wrong endianness.
  
  See also the closely related SDSCM00044038

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00044038
-------------------------------------------------------------------------------

Summary            : float library functions misbehave with --abi=eabi -mv5e
                     -me --float_support=fpalib
Affected Component : Runtime Support Libraries (RTS)

Description:
  Looking at the assembly code test_number gets converted to a double like I
  would expect but the comparison fails.
  
  See also the closely related SDSCM00044035

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00044056
-------------------------------------------------------------------------------

Summary            : Compiler misreports Misra warning 10.1
Affected Component : C/C++ Compiler (cl)

Description:
  Compiler misreports MISRA warning 10.1/R for the following code.
  
  
  typedef enum _MyEnum { One, Two } MyEnum;
  MyEnum MyVariable;
  
  int foo(void)  
  {      
      int result = 1;         
      if (One == MyVariable)  // fails here with MISRA-C:2004 10.1/R      
      {          result = 2;      }          
      return result;  
  } 
  
  Our coding style convention requires that the variable is at the right hand
  side. Therefore I don't want to swap One and MyVariable, although that makes
  the warning to disappear.
  
  Is that a bug in the MISRA checker? If not, why is the comparison of two terms
  not commutable?

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00045452
-------------------------------------------------------------------------------

Summary            : Compiler misreports MISRA warning 17.6
Affected Component : C/C++ Compiler (cl)

Description:
  Compiler misreports MISRA warning 17.6 with the attached code.
  
  (MISRA-C:2004 17.6/R) The address of an object with automatic storage shall
  not be assigned to another object that may persist after the first object has
  ceased to exist
  
  In the following code, the assignment of &myLocalStruct->data to myDataPtr in
  myFunc has MISRA 17.6 reported. myDataPtr only persists for the duration of
  the function, and therefore does not persist longer than data passed into
  that function.
  
  typedef struct
  {
      uint8 data;
  } Struct_T;
  
  void myFunc(Struct_T *myLocalStruct);
  void main(void);
  
  void myFunc(Struct_T *myLocalStruct)
  {
      uint8 *myDataPtr;
  
      myDataPtr = &myLocalStruct->data; /* (MISRA-C:2004 17.6/R) reported here */
  }
  
  void main(void)
  {
      Struct_T myStruct = { 0U };
  
      myFunc(&myStruct);
  }

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00045473
-------------------------------------------------------------------------------

Summary            : Compiler misreports violation of Misra 9.2 for zero
                     initialization of structures
Affected Component : C/C++ Compiler (cl)

Description:
  Compiler misreports violation of Misra 9.2 for zero initialization of
  structures.
  
  (MISRA-C:2004 9.2/R) Braces shall be used to indicate and match the structure
  in the non-zero initialisation of arrays and structures
  
  
  typedef struct
  {
  unsigned char nModuleId;
  unsigned char nInstanceId;
  unsigned char nApiId;
  unsigned char nErrorId;
  } DetLog_T;
  
  DetLog_T sctDetLog_M[0x100] = { 0U };

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00046102
-------------------------------------------------------------------------------

Summary            : MISRA 12.8 and MISRA 10.5 false positives
Affected Component : Parser

Description:
  I was wondering if the compiler's MISRA checking is reporting false positives.
  I have the following code
  
  #define DEF_X (0x00000001UL)
  #define DEF_Y (4U)
  
  static void foo(void)
  
  {
  
      uint32 nReadData;
  
      nReadData = DEF_X << DEF_Y;
  
  }
  
  This gives me a MISRA error...
  
  #1397-D (MISRA-C:2004 10.5/R) If the bitwise operators ~ and << are applied to
  #an operand of underlying type unsigned char or unsigned short, the result
  #shall be immediately cast to the underlying type of the operand.
  
  But the underlying type is a "UL" or 32bit unsigned integer.
  
  If I try to fix the error using the code...
  
   nReadData = (uint32)DEF_X << DEF_Y;
  
  This gives me a MISRA error...
  
  #1407-D (MISRA-C:2004 12.8/R) The right-hand operand of a shift operator shall
  #lie between zero and one less than the width in bits of the underlying type
  #of the left-hand operand
  
  But the right hand operator has a value of 4 and the left hand operator
  is 32 bits.
  
  The only way I can solve the problem is by assigning the #define values to
  temporary variables and then doing the shift operation with these.
  
  With this in mind I think the misra checking is not handling the #define
  values correctly.. Am I correct in this assumption?

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00046352
-------------------------------------------------------------------------------

Summary            : Disassembler does not emit certain instructions in UAL
                     form by default
Affected Component : Disassembler (dis)

Description:
  See the test case for SDSCM00046351.
  For instructions combining the S flag and a condition code, UAL requires the S
  to appear before the condition code, but the disassembler puts it afterward,
  in the pre-UAL style:
  UAL syntax:
  LSLSEQ R2, R2, #2
  LSLSNE R2, R2, #2
  disassembler output: (7A8)
  MOVEQS R2, R2, LSL #2
  MOVNES R2, R2, LSL #2
  I've no idea whether UAL expects the LSL or MOV syntax. rv40fromelf -c ouputs
  the LSL form, so I assume that's the UAL form.

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00047077
-------------------------------------------------------------------------------

Summary            : Incorrectly reduced double constant to float when
                     ultimate destination is short
Affected Component : C/C++ Compiler (cl)

Description:
  The expression ushort = 0.04f * 1000.0 gets a different value than ulong =
  0.04f * 1000.0, even in strict mode.
  
  To understand what you're seeing, you need to be aware of these facts:
  
      The value 0.04 is not exactly representable in IEEE-754 binary floating-
      point format. The value used in the compiler is approximately
      0.039999999105930328369140625 (exactly 0x1.47ae14p-5, in C99 hex format).
      1000.0 is a double-precision float constant because you didn't use the 'f'
      suffix. 1000.0f is a single-precision float constant.
      When you perform arithmetic on floating-point types, rounding occurs
      When you perform arithmetic on mixed types, the compiler must promote them
      to a common type, usually the larger of the two.
  
  Now, what's going on is that you are multiplying the single-precision variable
  fTest by a double-precision value 1000.0. This requires the compiler to
  promote the value in fTest to a double, which means adding a bunch of zeros on
  the end. The compiler then rounds the double-precision result, which has a lot
  of zeros at the end, so it doesn't round up. Then the value gets truncated to
  an integer type for assignment to an integer.
  
  The parser assumes that (because the ultimate destination has only 16 bits)
  that it is safe to convert 1000.0 to 1000.0f; the problem is that this changes
  the result. This is safe if the ultimate destination is float, because double-
  >float conversion rounds, but double->integer truncates.

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00047902
-------------------------------------------------------------------------------

Summary            : Predefined macro __TI_FPv4SPD16_SUPPORT__ should be
                     __TI_FPV4SPD16_SUPPORT__
Affected Component : Parser

Description:
  The convention for predefined macros representing subtargets and features is
  to capitalize every letter. The predefined macro __TI_FPv4SPD16_SUPPORT__
  should thus be __TI_FPV4SPD16_SUPPORT__. Recommend adding the latter, and
  keeping but deprecating the former

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00048267
-------------------------------------------------------------------------------

Summary            : Warning generated when using __curpc intrinsic on Thumb
                     2
Affected Component : Code Generator

Description:
  When using the __curpc intrinsic in Thumb 2 mode, the compiler generates code
  for which the assembler gives a warning. This should not affect the execution
  of the __curpc instruction, but could indicate incorrect execution of
  surrounding instructions.
  "file.asm", WARNING! at line 54: [W0004] Invalid instruction modifier(s)
  ignored
  MOVR A1, PC; MOVE REG-TO-REG ; [DPU_4_PIPE0] |2|

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00049284
-------------------------------------------------------------------------------

Summary            : Compiler misreports Misra warning 10.1
Affected Component : Parser

Description:
  Compiler misreports MISRA warning 10.1/R for the following code.
  
  typedef enum _MyEnum { One, Two } MyEnum;
  MyEnum MyVariable;
  
  int foo(void)  
  {      
      int result = 1;        
      if (One == MyVariable)  // fails here with MISRA-C:2004 10.1/R      
      {          result = 2;      }          
      return result;  
  } 

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00049911
-------------------------------------------------------------------------------

Summary            : __aeabi_dcmpun returns 1 for Inf and -Inf
Affected Component : Runtime Support Libraries (RTS)

Description:
  ARM EABI function __aeabi_dcmpun is a binary function which returns 1 if
  either operand is NaN, and 0 otherwise. However, when either operand is +-Inf,
  it returns 1. __aeabi_dcmpun does not have this bug.

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00050131
-------------------------------------------------------------------------------

Summary            : Local struct with non-constant initializer treated as
                     static scope variable
Affected Component : Parser

Description:
  We've discovered a problem where the C++ compiler places a local structure
  variable not on the stack but in the data segment, as if it was a static
  structure. The problem is especially insidious because the issue will only
  have an impact on re-entrance.
  
  The problem seems to occur only for C++ files, and only if the structure
  initializer list contains a variable. Constant initializer lists do not
  trigger the issue.
  
  The structure in the first function will be allocated on the stack, but the
  structure in the second will be compiled as if it was declared static.

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00050499
-------------------------------------------------------------------------------

Summary            : The .label assembler directive should not be accepted
                     when assembling for ELF.
Affected Component : Assembler

Description:
  The .label directive creates a symbol that will have the value of the load
  address of a section. This cannot be done in ELF so the directive should issue
  an error. It's usefulness has been subsumed by other mechanisms (symbols
  defined in the linker command file and copy tables).

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00050861
-------------------------------------------------------------------------------

Summary            : Should accept 2-operand add in ARM mode
Affected Component : Assembler

Description:
  TI's assembler does not accept the 2-operand syntax for specifying the 3-
  operand ARM ADD instruction. Although the UAL doesn't seem to require the tool
  to allow this syntax, RVCT accepts this form, so we should, too.

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00051065
-------------------------------------------------------------------------------

Summary            : Should accept 2-operand SUB SP in Thumb1/UAL mode
Affected Component : Assembler

Description:
  In thumb1/UAL mode, the assembler mistakenly emits an error when given the
  instruction "SUB SP, SP, #508" This syntax is specified directly in the ARM,
  so it should be supported.
  
  In thumb2 mode, the assembler mistakenly turns this into a 32-bit SUB.W SP,
  SP, #508. It should instead be a 16-bit instruction.

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00051069
-------------------------------------------------------------------------------

Summary            : Should allow "ADD R0, R1, #0xfff" for v6m0
Affected Component : Assembler

Description:
  The non-status setting two-register ADD immediate was actually added for T2,
  so it can be used on v6m0 as well.

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00051086
-------------------------------------------------------------------------------

Summary            : Assembler accepts but mistranslates BLLT in v7 thumb
                     mode
Affected Component : Assembler

Description:
  For v7 thumb 2 mode, the assembler should accept conditional instructions and
  automatically generate the appropriate IT instruction preceding it. (See
  SDSCM00051087)
  
  For v7 thumb mode, the assembler should accept the BLLT instruction, which is
  BL conditioned with LT, and turn it into "IT LT" followed by "BL LT." However,
  it accepts the instruction and turns it into "BL", which is wrong. While
  SDSCM00051087 is unsatisfied, the assembler should emit an error for "BLLT."
  After SDSCM00051087 is satisfied, the assembler should accept it and turn it
  into "IT LT" followed by "BL LT".

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00051111
-------------------------------------------------------------------------------

Summary            : Missing AEABI_COMPATIBILITY_MODE link-time constants
Affected Component : Runtime Support Libraries (RTS)

Description:
  The RTS is missing the following link-time constants required in
  AEABI_COMPATIBILITY_MODE mode:
  
   __aeabi_HUGE_VAL
   __aeabi_HUGE_VALF
   __aeabi_HUGE_VALL
   __aeabi_INFINITY
   __aeabi_NAN
   __aeabi_LC_ALL
  
  Can we even represent HUGE_VAL, as it is a 64-bit value and our linker only
  has 32-bit constants?

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00051113
-------------------------------------------------------------------------------

Summary            : Missing __aeabi_read_tp
Affected Component : Runtime Support Libraries (RTS)

Description:
  Function __aeabi_read_tp is required for ARM EABI compatibility, but we don't
  provide it. TI does not support thread-local-storage for ARM, but C6x has it,
  so it wouldn't be that difficult to add.

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00051114
-------------------------------------------------------------------------------

Summary            : Missing half-precision float conversion functions
Affected Component : Runtime Support Libraries (RTS)

Description:
  The half-precision float conversion functions are required for ARM EABI
  compatibility, but we don't provide them. TI does not support half-precision
  float, but these functions are still required for interlinking. These
  functions are:
  
  __aeabi_d2h
  __aeabi_d2h_alt
  __aeabi_f2h
  __aeabi_f2h_alt
  __aeabi_h2f
  __aeabi_h2f_alt

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00051165
-------------------------------------------------------------------------------

Summary            : Should accept "LDRD R8,[R1]" in Thumb-2 mode
Affected Component : Assembler

Description:
  The assembler should accept "LDRD R8,[R1]" and translate it as if it were the
  canonical form "LDRD R8,R9,[R1]". It does do this in ARM mode, but fails to do
  so in Thumb-2 mode. RVDS accepts it in both modes.

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00051353
-------------------------------------------------------------------------------

Summary            : MISRA does not recognize #pragma as preprocessing
                     directive for 19.1
Affected Component : Parser

Description:
  MISRA does not recognize #pragma as preprocessing directive for 19.1. 19.1
  says that "#include statements in a file should only be preceded by other
  preprocessor directives or comments", but #pragma is...

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00051367
-------------------------------------------------------------------------------

Summary            : Disable diagnostic 1558 (--float_operations_allowed
                     diagnostic) in standard header files
Affected Component : Runtime Support Libraries (RTS)

Description:
  The --float_operations_allowed option is used to identify floating point
  operations and issue an error if the user doesn't want them in the program. A
  program that includes math.h will generate diagnostics if either none or 32 is
  used as an argument. The emitting of the diagnostics is probably OK for none
  since users really shouldn't include math.h if no floating point is to be
  done, but it is a problem for 32-bit operations. If a user wants to only use
  32-bit floating point, it is reasonable for them to include math.h. We should
  suppress the diagnostics from the standard header files.

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00051484
-------------------------------------------------------------------------------

Summary            : Compiler does not respect partial overrides in C99
                     designated initializers
Affected Component : Parser

Description:
  Compiler does not respect partial overrides in C99 designated initializers
  Caught by ACE C99/6/7/8/t7.c
  See function lower_aggregate_designated_initializers in lower_init.c
  
  Both GCC-4.9.2 and EDG 4.4.1 behave this way. This appears to be a standard
  interpretation issue. The standard says "The initialization shall occur in
  initializer list order, each initializer provided for a particular subobject
  overriding any previously listed initializer for the same subobject." EDG
  apparently interprets this in the case of { .m = x, .m.a = 1, .m.b = 2 } with
  .m.a overriding the entire initialization .m=x; but in that case why doesn't
  .m.b override .m.a?

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00051485
-------------------------------------------------------------------------------

Summary            : Incorrect reordering of complicated float expression
Affected Component : Optimizer

Description:
  When the optimizer is used, the result is incorrect, even when --
  fp_mode=strict is used. The problem is that the optimizer is incorrectly
  rearranging the complicated float expression in the increment part of
  the for loop

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00051556
-------------------------------------------------------------------------------

Summary            : formal parameter of strtod should be const char **
Affected Component : Runtime Support Libraries (RTS)

Description:
  C99 expects the formal parameters of strtod to be const char **, but we don't
  define it that way. Same with strtold. Furthermore, strtof doesn't exist (see
  SDSCM00052146)

-------------------------------------------------------------------------------
KNOWN ISSUE SDSCM00051660
-------------------------------------------------------------------------------

Summary            : When the imaginary part of z is INFINITY, cprojf(z) is
                     NOT equivalent to INFINITY + I * copysign(0.0,
                     cimagf(z))
Affected Component : C/C++ Compiler (cl)

Description:
  When the imaginary part of z is INFINITY, cprojf(z) is equivalent to INFINITY
  + I * copysign(0.0, cimagf(z))

